{"version":3,"file":"modern.js","sources":["../node_modules/fast-unique-numbers/build/es2019/factories/cache.js","../node_modules/fast-unique-numbers/build/es2019/factories/generate-unique-number.js","../node_modules/fast-unique-numbers/build/es2019/module.js","../node_modules/worker-timers/build/es2019/factories/load-worker-timers.js","../node_modules/worker-timers/build/es2019/module.js","../node_modules/worker-timers-broker/build/es2019/module.js","../node_modules/worker-timers-broker/build/es2019/guards/call-notification.js","../node_modules/worker-timers-broker/build/es2019/guards/clear-response.js","../node_modules/worker-timers/build/es2019/worker/worker.js","../src/timer.js","../src/utils.js","../src/MessageChannel/methods/broadcastChannel.js","../src/MessageChannel/ObliviousSet.js","../src/MessageChannel/methods/localStorage.js","../src/MessageChannel/methods/simulate.js","../src/MessageChannel/methodChooser.js","../src/MessageChannel/MessageChannel.js","../src/MessageChannel/leaderElection.js","../src/TabManager.js","../src/IdleTimer.js","../src/useIdleTimer.js"],"sourcesContent":["export const createCache = (lastNumberWeakMap) => {\n    return (collection, nextNumber) => {\n        lastNumberWeakMap.set(collection, nextNumber);\n        return nextNumber;\n    };\n};\n//# sourceMappingURL=cache.js.map","/*\n * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n * is fairly new.\n */\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\nconst TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\nconst TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\nexport const createGenerateUniqueNumber = (cache, lastNumberWeakMap) => {\n    return (collection) => {\n        const lastNumber = lastNumberWeakMap.get(collection);\n        /*\n         * Let's try the cheapest algorithm first. It might fail to produce a new\n         * number, but it is so cheap that it is okay to take the risk. Just\n         * increase the last number by one or reset it to 0 if we reached the upper\n         * bound of SMIs (which stands for small integers). When the last number is\n         * unknown it is assumed that the collection contains zero based consecutive\n         * numbers.\n         */\n        let nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n        if (!collection.has(nextNumber)) {\n            return cache(collection, nextNumber);\n        }\n        /*\n         * If there are less than half of 2 ** 30 numbers stored in the collection,\n         * the chance to generate a new random number in the range from 0 to 2 ** 30\n         * is at least 50%. It's benifitial to use only SMIs because they perform\n         * much better in any environment based on V8.\n         */\n        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n            while (collection.has(nextNumber)) {\n                nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n            }\n            return cache(collection, nextNumber);\n        }\n        // Quickly check if there is a theoretical chance to generate a new number.\n        if (collection.size > MAX_SAFE_INTEGER) {\n            throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n        }\n        // Otherwise use the full scale of safely usable integers.\n        while (collection.has(nextNumber)) {\n            nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n        }\n        return cache(collection, nextNumber);\n    };\n};\n//# sourceMappingURL=generate-unique-number.js.map","import { createAddUniqueNumber } from './factories/add-unique-number';\nimport { createCache } from './factories/cache';\nimport { createGenerateUniqueNumber } from './factories/generate-unique-number';\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './types/index';\nconst LAST_NUMBER_WEAK_MAP = new WeakMap();\nconst cache = createCache(LAST_NUMBER_WEAK_MAP);\nconst generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\nconst addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\nexport { addUniqueNumber, generateUniqueNumber };\n//# sourceMappingURL=module.js.map","let workerTimers = null;\nexport const createLoadWorkerTimers = (load, worker) => {\n    return () => {\n        if (workerTimers !== null) {\n            return workerTimers;\n        }\n        const blob = new Blob([worker], { type: 'application/javascript; charset=utf-8' });\n        const url = URL.createObjectURL(blob);\n        workerTimers = load(url);\n        // Bug #1: Edge doesn't like the URL to be revoked directly.\n        workerTimers.setTimeout(() => URL.revokeObjectURL(url), 0);\n        return workerTimers;\n    };\n};\n//# sourceMappingURL=load-worker-timers.js.map","import { load } from 'worker-timers-broker';\nimport { createLoadWorkerTimers } from './factories/load-worker-timers';\nimport { worker } from './worker/worker';\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './types/index';\nconst loadWorkerTimers = createLoadWorkerTimers(load, worker);\nexport const clearInterval = (timerId) => loadWorkerTimers().clearInterval(timerId);\nexport const clearTimeout = (timerId) => loadWorkerTimers().clearTimeout(timerId);\nexport const setInterval = (func, delay) => loadWorkerTimers().setInterval(func, delay);\nexport const setTimeout = (func, delay) => loadWorkerTimers().setTimeout(func, delay);\n//# sourceMappingURL=module.js.map","import { generateUniqueNumber } from 'fast-unique-numbers';\nimport { isCallNotification } from './guards/call-notification';\nimport { isClearResponse } from './guards/clear-response';\nexport const load = (url) => {\n    // Prefilling the Maps with a function indexed by zero is necessary to be compliant with the specification.\n    const scheduledIntervalFunctions = new Map([[0, () => { }]]); // tslint:disable-line no-empty\n    const scheduledTimeoutFunctions = new Map([[0, () => { }]]); // tslint:disable-line no-empty\n    const unrespondedRequests = new Map();\n    const worker = new Worker(url);\n    worker.addEventListener('message', ({ data }) => {\n        if (isCallNotification(data)) {\n            const { params: { timerId, timerType } } = data;\n            if (timerType === 'interval') {\n                const idOrFunc = scheduledIntervalFunctions.get(timerId);\n                if (typeof idOrFunc === 'number') {\n                    const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);\n                    if (timerIdAndTimerType === undefined ||\n                        timerIdAndTimerType.timerId !== timerId ||\n                        timerIdAndTimerType.timerType !== timerType) {\n                        throw new Error('The timer is in an undefined state.');\n                    }\n                }\n                else if (typeof idOrFunc !== 'undefined') {\n                    idOrFunc();\n                }\n                else {\n                    throw new Error('The timer is in an undefined state.');\n                }\n            }\n            else if (timerType === 'timeout') {\n                const idOrFunc = scheduledTimeoutFunctions.get(timerId);\n                if (typeof idOrFunc === 'number') {\n                    const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);\n                    if (timerIdAndTimerType === undefined ||\n                        timerIdAndTimerType.timerId !== timerId ||\n                        timerIdAndTimerType.timerType !== timerType) {\n                        throw new Error('The timer is in an undefined state.');\n                    }\n                }\n                else if (typeof idOrFunc !== 'undefined') {\n                    idOrFunc();\n                    // A timeout can be savely deleted because it is only called once.\n                    scheduledTimeoutFunctions.delete(timerId);\n                }\n                else {\n                    throw new Error('The timer is in an undefined state.');\n                }\n            }\n        }\n        else if (isClearResponse(data)) {\n            const { id } = data;\n            const timerIdAndTimerType = unrespondedRequests.get(id);\n            if (timerIdAndTimerType === undefined) {\n                throw new Error('The timer is in an undefined state.');\n            }\n            const { timerId, timerType } = timerIdAndTimerType;\n            unrespondedRequests.delete(id);\n            if (timerType === 'interval') {\n                scheduledIntervalFunctions.delete(timerId);\n            }\n            else {\n                scheduledTimeoutFunctions.delete(timerId);\n            }\n        }\n        else {\n            const { error: { message } } = data;\n            throw new Error(message);\n        }\n    });\n    const clearInterval = (timerId) => {\n        const id = generateUniqueNumber(unrespondedRequests);\n        unrespondedRequests.set(id, { timerId, timerType: 'interval' });\n        scheduledIntervalFunctions.set(timerId, id);\n        worker.postMessage({\n            id,\n            method: 'clear',\n            params: { timerId, timerType: 'interval' }\n        });\n    };\n    const clearTimeout = (timerId) => {\n        const id = generateUniqueNumber(unrespondedRequests);\n        unrespondedRequests.set(id, { timerId, timerType: 'timeout' });\n        scheduledTimeoutFunctions.set(timerId, id);\n        worker.postMessage({\n            id,\n            method: 'clear',\n            params: { timerId, timerType: 'timeout' }\n        });\n    };\n    const setInterval = (func, delay) => {\n        const timerId = generateUniqueNumber(scheduledIntervalFunctions);\n        scheduledIntervalFunctions.set(timerId, () => {\n            func();\n            // Doublecheck if the interval should still be rescheduled because it could have been cleared inside of func().\n            if (typeof scheduledIntervalFunctions.get(timerId) === 'function') {\n                worker.postMessage({\n                    id: null,\n                    method: 'set',\n                    params: {\n                        delay,\n                        now: performance.now(),\n                        timerId,\n                        timerType: 'interval'\n                    }\n                });\n            }\n        });\n        worker.postMessage({\n            id: null,\n            method: 'set',\n            params: {\n                delay,\n                now: performance.now(),\n                timerId,\n                timerType: 'interval'\n            }\n        });\n        return timerId;\n    };\n    const setTimeout = (func, delay) => {\n        const timerId = generateUniqueNumber(scheduledTimeoutFunctions);\n        scheduledTimeoutFunctions.set(timerId, func);\n        worker.postMessage({\n            id: null,\n            method: 'set',\n            params: {\n                delay,\n                now: performance.now(),\n                timerId,\n                timerType: 'timeout'\n            }\n        });\n        return timerId;\n    };\n    return {\n        clearInterval,\n        clearTimeout,\n        setInterval,\n        setTimeout\n    };\n};\n//# sourceMappingURL=module.js.map","export const isCallNotification = (message) => {\n    return message.method !== undefined && message.method === 'call';\n};\n//# sourceMappingURL=call-notification.js.map","export const isClearResponse = (message) => {\n    return message.error === null && typeof message.id === 'number';\n};\n//# sourceMappingURL=clear-response.js.map","// This is the minified and stringified code of the worker-timers-worker package.\nexport const worker = `(()=>{\"use strict\";const e=new Map,t=new Map,r=(e,t)=>{let r,o;const i=performance.now();r=i,o=e-Math.max(0,i-t);return{expected:r+o,remainingDelay:o}},o=(e,t,r,i)=>{const s=performance.now();s>r?postMessage({id:null,method:\"call\",params:{timerId:t,timerType:i}}):e.set(t,setTimeout(o,r-s,e,t,r,i))};addEventListener(\"message\",(i=>{let{data:s}=i;try{if(\"clear\"===s.method){const{id:r,params:{timerId:o,timerType:i}}=s;if(\"interval\"===i)(t=>{const r=e.get(t);if(void 0===r)throw new Error('There is no interval scheduled with the given id \"'.concat(t,'\".'));clearTimeout(r),e.delete(t)})(o),postMessage({error:null,id:r});else{if(\"timeout\"!==i)throw new Error('The given type \"'.concat(i,'\" is not supported'));(e=>{const r=t.get(e);if(void 0===r)throw new Error('There is no timeout scheduled with the given id \"'.concat(e,'\".'));clearTimeout(r),t.delete(e)})(o),postMessage({error:null,id:r})}}else{if(\"set\"!==s.method)throw new Error('The given method \"'.concat(s.method,'\" is not supported'));{const{params:{delay:i,now:n,timerId:a,timerType:d}}=s;if(\"interval\"===d)((t,i,s)=>{const{expected:n,remainingDelay:a}=r(t,s);e.set(i,setTimeout(o,a,e,i,n,\"interval\"))})(i,a,n);else{if(\"timeout\"!==d)throw new Error('The given type \"'.concat(d,'\" is not supported'));((e,i,s)=>{const{expected:n,remainingDelay:a}=r(e,s);t.set(i,setTimeout(o,a,t,i,n,\"timeout\"))})(i,a,n)}}}}catch(e){postMessage({error:{message:e.message},id:s.id,result:null})}}))})();`; // tslint:disable-line:max-line-length\n//# sourceMappingURL=worker.js.map","import * as workerTimers from 'worker-timers'\n\nconst isWebWorkerSupported = !!window.Worker && typeof Worker !== 'undefined'\n\nconst timer = {}\n\ntimer.clearInterval = (intervalId) => {\n  if (isWebWorkerSupported) {\n    workerTimers.clearInterval(intervalId)\n  } else {\n    clearInterval(intervalId)\n  }\n}\n\ntimer.clearTimeout = (timeoutId) => {\n  if (isWebWorkerSupported) {\n    workerTimers.clearTimeout(timeoutId)\n  } else {\n    clearTimeout(timeoutId)\n  }\n}\n\ntimer.setInterval = (callback, delay) => {\n  if (isWebWorkerSupported) {\n    workerTimers.setInterval(callback, delay)\n  } else {\n    setInterval(callback, delay)\n  }\n}\n\ntimer.setTimeout = (callback, delay) => {\n  if (isWebWorkerSupported) {\n    workerTimers.setTimeout(callback, delay)\n  } else {\n    setTimeout(callback, delay)\n  }\n}\n\nexport default timer\n","import timer from './timer'\n\n/**\n * Determine if we are in a browser\n * or a server environment\n * @type {Boolean}\n * @private\n */\nexport const IS_BROWSER =\n  (typeof window === 'undefined' ? 'undefined' : typeof window) === 'object'\n\n/**\n * Default element to listen for events on\n * @type {Object}\n * @private\n */\nexport const DEFAULT_ELEMENT = IS_BROWSER ? document : {}\n\n/**\n * The default events to determine activity\n * @type {Array}\n * @private\n */\nexport const DEFAULT_EVENTS = [\n  'mousemove',\n  'keydown',\n  'wheel',\n  'DOMMouseScroll',\n  'mousewheel',\n  'mousedown',\n  'touchstart',\n  'touchmove',\n  'MSPointerDown',\n  'MSPointerMove',\n  'visibilitychange'\n]\n\n/**\n * Creates a debounced function that delays invoking func until\n * after delay milliseconds has elapsed since the last time the\n * debounced function was invoked.\n * @name debounced\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n * @private\n **/\nexport function debounced (fn, delay) {\n  let timerId\n  function result (...args) {\n    if (timerId) {\n      timer.clearTimeout(timerId)\n    }\n    timerId = timer.setTimeout(() => {\n      fn(...args)\n      timerId = null\n    }, delay)\n  }\n\n  result.cancel = function () {\n    timer.clearTimeout(timerId)\n  }\n\n  return result\n}\n\n/**\n * Creates a throttled function that only invokes func at most\n * once per every wait milliseconds.\n * @name throttled\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n * @private\n **/\nexport function throttled (fn, delay) {\n  let lastCall = 0\n  return function (...args) {\n    const now = new Date().getTime()\n    if (now - lastCall < delay) {\n      return\n    }\n    lastCall = now\n    return fn(...args)\n  }\n}\n\nlet lastMs = 0\nlet additional = 0\n\n/**\n * Returns current time in microseconds.\n *\n * @returns {Number} current time in microseconds\n * @private\n */\nexport function microSeconds () {\n  const ms = new Date().getTime()\n  if (ms === lastMs) {\n    additional++\n    return ms * 1000 + additional\n  } else {\n    lastMs = ms\n    additional = 0\n    return ms * 1000\n  }\n}\n\n/**\n * Generate and return a random token.\n *\n * @returns {String} Random token.\n * @private\n */\nexport function randomToken () {\n  return Math.random().toString(36).substring(2)\n}\n\n/**\n * Checks if a js object is a promise.\n *\n * @param {*} obj  Any javascript object.\n * @returns {Boolean} Wether or not this object is a promise.\n */\nexport function isPromise (obj) {\n  if (obj && typeof obj.then === 'function') {\n    /* istanbul ignore next */\n    return true\n  } else {\n    return false\n  }\n}\n\n/**\n * Sleeps for x amount of milliseconds.\n *\n * @param {Number} time   Amount of time in milliseconds.\n * @returns {Promise}\n * @private\n */\nexport function sleep (time = 0) {\n  return new Promise(resolve => timer.setTimeout(resolve, time))\n}\n\n/**\n * Get the current timestamp.\n *\n * @returns {Number}\n * @private\n */\nexport function now () {\n  return new Date().getTime()\n}\n\n/**\n * Waits until the given function returns true\n * @param  {function}  fn\n * @return {Promise}\n */\nexport function waitUntil (fn, timeout = 0, interval = 20) {\n  let timedOut = false\n  let ok = false\n\n  /* istanbul ignore next */\n  if (timeout !== 0) {\n    sleep(timeout).then(() => {\n      timedOut = true\n    })\n  }\n\n  return new Promise((resolve, reject) => {\n    const runLoop = () => {\n      if (ok) {\n        resolve()\n        return\n      }\n      /* istanbul ignore next */\n      if (timedOut) {\n        reject(new Error(`❌ waitUntil reached timeout of ${timeout}ms`))\n        return\n      }\n      sleep(interval).then(() => {\n        ok = fn()\n        runLoop()\n      })\n    }\n    runLoop()\n  })\n}\n","/* eslint-env browser */\nimport { microSeconds } from '../../utils'\n\nexport const type = 'broadcastChannel'\n\nexport function create (channelName) {\n  const state = {\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName)\n  }\n\n  state.bc.onmessage = msg => {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data)\n    }\n  }\n\n  return state\n}\n\nexport function close (channelState) {\n  channelState.bc.close()\n}\n\nexport function postMessage (channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false)\n    return Promise.resolve()\n  } catch (err) {\n    /* istanbul ignore next */\n    return Promise.reject(err)\n  }\n}\n\nexport function onMessage (channelState, fn) {\n  channelState.messagesCallback = fn\n}\n\nexport function canBeUsed () {\n  if (typeof BroadcastChannel === 'function') {\n    return true\n  } else {\n    /* istanbul ignore next */\n    return false\n  }\n}\n\nexport function averageResponseTime () {\n  return 150\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import { now } from '../utils'\n\nexport default class ObliviousSet {\n  constructor (ttl = 1000 * 60) {\n    this.ttl = ttl\n    this.set = new Set()\n    this.timeMap = new Map()\n  }\n\n  has (value) {\n    return this.set.has(value)\n  }\n\n  add (value) {\n    this.timeMap.set(value, now())\n    this.set.add(value)\n    this._removeTooOldValues()\n  }\n\n  clear () {\n    this.set.clear()\n    this.timeMap.clear()\n  }\n\n  _removeTooOldValues () {\n    const olderThen = now() - this.ttl\n    const iterator = this.set[Symbol.iterator]()\n\n    while (true) {\n      const value = iterator.next().value\n      if (!value) return // no more elements\n      const time = this.timeMap.get(value)\n      if (time < olderThen) {\n        this.timeMap.delete(value)\n        this.set.delete(value)\n      } else {\n        // We reached a value that is not old enough\n        return\n      }\n    }\n  }\n}\n","import ObliviousSet from '../ObliviousSet'\n\nimport {\n  randomToken,\n  microSeconds\n} from '../../utils'\n\nexport const type = 'localStorage'\n\n/**\n * Returns local storage instance\n */\nexport function getLocalStorage () {\n  let localStorage\n  if (typeof window === 'undefined') return null\n  try {\n    localStorage = window.localStorage\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage\n  } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n  return localStorage\n}\n\nexport function storageKey (channelName) {\n  return channelName\n}\n\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\nexport function postMessage (channelState, messageJson) {\n  return new Promise(resolve => {\n    const key = storageKey(channelState.channelName)\n    const writeObj = {\n      token: randomToken(),\n      time: new Date().getTime(),\n      data: messageJson,\n      uuid: channelState.uuid\n    }\n    const value = JSON.stringify(writeObj)\n    getLocalStorage().setItem(key, value)\n\n    /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n    const ev = document.createEvent('Event')\n    ev.initEvent('storage', true, true)\n    ev.key = key\n    ev.newValue = value\n    window.dispatchEvent(ev)\n\n    resolve()\n  })\n}\n\nexport function addStorageEventListener (channelName, fn) {\n  const key = storageKey(channelName)\n  const listener = ev => {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue))\n    }\n  }\n  window.addEventListener('storage', listener)\n  return listener\n}\nexport function removeStorageEventListener (listener) {\n  window.removeEventListener('storage', listener)\n}\n\nexport function create (channelName, options = {}) {\n  if (!canBeUsed()) {\n    /* istanbul ignore next */\n    throw new Error('❌ localStorage cannot be used.')\n  }\n\n  const uuid = randomToken()\n\n  /**\n     * eMIs\n     * contains all messages that have been emitted before\n     * @type {ObliviousSet}\n     */\n  const eMIs = new ObliviousSet(options.removeTimeout)\n\n  const state = {\n    channelName,\n    uuid,\n    eMIs // emittedMessagesIds\n  }\n\n  state.listener = addStorageEventListener(\n    channelName,\n    (msgObj) => {\n      if (!state.messagesCallback) return // no listener\n      if (msgObj.uuid === uuid) return // own message\n      if (!msgObj.token || eMIs.has(msgObj.token)) return // already emitted\n      if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return // too old\n\n      eMIs.add(msgObj.token)\n      state.messagesCallback(msgObj.data)\n    }\n  )\n\n  return state\n}\n\nexport function close (channelState) {\n  removeStorageEventListener(channelState.listener)\n}\n\nexport function onMessage (channelState, fn, time) {\n  channelState.messagesCallbackTime = time\n  channelState.messagesCallback = fn\n}\n\nexport function canBeUsed () {\n  const ls = getLocalStorage()\n\n  if (!ls) return false\n\n  try {\n    const key = '__check'\n    ls.setItem(key, 'works')\n    ls.removeItem(key)\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n\n    /* istanbul ignore next */\n    return false\n  }\n\n  return true\n}\n\n/* istanbul ignore next */\nexport function averageResponseTime () {\n  const defaultTime = 120\n  const userAgent = navigator.userAgent.toLowerCase()\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2\n  }\n  return defaultTime\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import timer from '../../timer'\nimport { microSeconds } from '../../utils'\n\nexport const type = 'simulate'\n\nconst SIMULATE_CHANNELS = new Set()\n\nexport function create (channelName) {\n  const state = {\n    name: channelName,\n    messagesCallback: null\n  }\n  SIMULATE_CHANNELS.add(state)\n\n  return state\n}\n\nexport function close (channelState) {\n  SIMULATE_CHANNELS.delete(channelState)\n}\n\nexport function postMessage (channelState, messageJson) {\n  return new Promise(resolve => timer.setTimeout(() => {\n    const channelArray = Array.from(SIMULATE_CHANNELS)\n    channelArray\n      .filter(channel => channel.name === channelState.name)\n      .filter(channel => channel !== channelState)\n      .filter(channel => !!channel.messagesCallback)\n      .forEach(channel => channel.messagesCallback(messageJson))\n    resolve()\n  }, 5))\n}\n\nexport function onMessage (channelState, fn) {\n  channelState.messagesCallback = fn\n}\n\n/* istanbul ignore next */\nexport function canBeUsed () {\n  return true\n}\n\n/* istanbul ignore next */\nexport function averageResponseTime () {\n  return 5\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import BroadcastChannelMethod from './methods/broadcastChannel'\nimport LocalStorageMethod from './methods/localStorage'\nimport SimulateMethod from './methods/simulate'\n\n// Order is important\nconst METHODS = [\n  BroadcastChannelMethod,\n  LocalStorageMethod\n]\n\nexport function chooseMethod (options = {}) {\n  if (options.type) {\n    // For testing\n    if (options.type === 'simulate') {\n      return SimulateMethod\n    }\n\n    // Chosen type\n    const method = METHODS.find(m => m.type === options.type)\n    if (!method) throw new Error(`❌ Method ${options.type} is not supported.`)\n    else return method\n  }\n\n  const useMethod = METHODS.find(method => method.canBeUsed())\n\n  /* istanbul ignore next */\n  if (!useMethod) {\n    throw new Error(`❌ No method found ${JSON.stringify(METHODS.map(m => m.type))}`)\n  }\n  return useMethod\n}\n","import { chooseMethod } from './methodChooser'\nimport { isPromise } from '../utils'\n\nexport class MessageChannel {\n  constructor (name, options = {}) {\n    this.name = name\n    this.options = options\n    this.method = chooseMethod(this.options)\n    this.closed = false\n\n    // isListening\n    this._isListening = false\n\n    /**\n     * _onMessageListener\n     * setting onmessage twice,\n     * will overwrite the first listener\n     */\n    this._onMessageListener = null\n\n    /**\n     * _addEventListeners\n     */\n    this._addEventListeners = {\n      message: [],\n      internal: []\n    }\n\n    /**\n     * Un send message promises\n     * where the sending is still in progress\n     * @type {Set<Promise>}\n     */\n    this._unSendMessagePromises = new Set()\n\n    /**\n     * _beforeClose\n     * array of promises that will be awaited\n     * before the channel is closed\n     */\n    this._beforeClose = []\n\n    /**\n     * _preparePromise\n     */\n    this._preparePromises = null\n    _prepareChannel(this)\n  }\n\n  postMessage (msg) {\n    if (this.closed) {\n      throw new Error(\n        '❌ Cannot post message after channel has closed'\n      )\n    }\n    return _post(this, 'message', msg)\n  }\n\n  postInternal (msg) {\n    return _post(this, 'internal', msg)\n  }\n\n  set onmessage (fn) {\n    const time = this.method.microSeconds()\n    const listenObj = {\n      time,\n      fn\n    }\n    _removeListenerObject(this, 'message', this._onMessageListener)\n    if (fn && typeof fn === 'function') {\n      this._onMessageListener = listenObj\n      _addListenerObject(this, 'message', listenObj)\n    } else {\n      /* istanbul ignore next */\n      this._onMessageListener = null\n    }\n  }\n\n  /* istanbul ignore next */\n  get onmessage () {\n    return this._onMessageListener\n  }\n\n  addEventListener (type, fn) {\n    const time = this.method.microSeconds()\n    const listenObj = {\n      time,\n      fn\n    }\n    _addListenerObject(this, type, listenObj)\n  }\n\n  removeEventListener (type, fn) {\n    const obj = this._addEventListeners[type].find(obj => obj.fn === fn)\n    _removeListenerObject(this, type, obj)\n  }\n\n  close () {\n    if (this.closed) {\n      return\n    }\n    this.closed = true\n    const awaitPrepare = this._preparePromises ? this._preparePromises : Promise.resolve()\n\n    this._onMessageListener = null\n    this._addEventListeners.message = []\n\n    return awaitPrepare\n      // Wait until all current sending are processed\n      .then(() => Promise.all(Array.from(this._unSendMessagePromises)))\n      // Run before-close hooks\n      .then(() => Promise.all(this._beforeClose.map(fn => fn())))\n      // Close the channel\n      .then(() => this.method.close(this._state))\n  }\n\n  get type () {\n    return this.method.type\n  }\n\n  isClosed () {\n    return this.closed\n  }\n}\n\nfunction _post (messageChannel, type, msg) {\n  const time = messageChannel.method.microSeconds()\n  const msgObj = {\n    time,\n    type,\n    data: msg\n  }\n\n  const awaitPrepare = messageChannel._preparePromises ? messageChannel._preparePromises : Promise.resolve()\n  return awaitPrepare.then(() => {\n    const sendPromise = messageChannel.method.postMessage(\n      messageChannel._state,\n      msgObj\n    )\n\n    // add/remove to un-send messages list\n    messageChannel._unSendMessagePromises.add(sendPromise)\n    sendPromise\n      .catch()\n      .then(() => messageChannel._unSendMessagePromises.delete(sendPromise))\n\n    return sendPromise\n  })\n}\n\nfunction _prepareChannel (channel) {\n  const maybePromise = channel.method.create(channel.name, channel.options)\n  /* istanbul ignore next */\n  if (isPromise(maybePromise)) {\n    channel._preparePromises = maybePromise\n    maybePromise.then(s => {\n      channel._state = s\n    })\n  } else {\n    channel._state = maybePromise\n  }\n}\n\nfunction _hasMessageListeners (channel) {\n  if (channel._addEventListeners.message.length > 0) return true\n  if (channel._addEventListeners.internal.length > 0) return true\n  return false\n}\n\nfunction _addListenerObject (channel, type, obj) {\n  channel._addEventListeners[type].push(obj)\n  _startListening(channel)\n}\n\nfunction _removeListenerObject (channel, type, obj) {\n  channel._addEventListeners[type] = channel._addEventListeners[type].filter(o => o !== obj)\n  _stopListening(channel)\n}\n\nfunction _startListening (channel) {\n  if (!channel._isListening && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n\n    const listenerFn = msgObj => {\n      channel._addEventListeners[msgObj.type].forEach(obj => {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data)\n        }\n      })\n    }\n\n    const time = channel.method.microSeconds()\n    if (channel._preparePromises) {\n      /* istanbul ignore next */\n      channel._preparePromises.then(() => {\n        channel._isListening = true\n        channel.method.onMessage(\n          channel._state,\n          listenerFn,\n          time\n        )\n      })\n    } else {\n      channel._isListening = true\n      channel.method.onMessage(\n        channel._state,\n        listenerFn,\n        time\n      )\n    }\n  }\n}\n\nfunction _stopListening (channel) {\n  if (channel._isListening && !_hasMessageListeners(channel)) {\n    // no one is listening, stop subscribing\n    channel._isListening = false\n    const time = channel.method.microSeconds()\n    channel.method.onMessage(\n      channel._state,\n      null,\n      time\n    )\n  }\n}\n","import timer from '../timer'\nimport { IS_BROWSER, sleep, randomToken } from '../utils'\n\nclass LeaderElection {\n  constructor (channel, options) {\n    this._channel = channel\n    this._options = options\n\n    this.isLeader = false\n    this.isDead = false\n    this.token = randomToken()\n\n    this._isApplying = false\n    this._reApply = false\n\n    // things to clean up\n    this._unloadFns = []\n    this._listeners = []\n    this._intervals = []\n    this._duplicateListeners = () => { }\n    this._duplicateCalled = false\n    this._onBeforeDie = async () => {}\n\n    const unloadFn = async () => this.die()\n\n    if (IS_BROWSER) {\n      window.addEventListener('beforeUnload', unloadFn)\n      window.addEventListener('unload', unloadFn)\n\n      this._unloadFns.push(['beforeUnload', unloadFn])\n      this._unloadFns.push(['unload', unloadFn])\n    }\n  }\n\n  applyOnce () {\n    if (this.isLeader) return Promise.resolve(false)\n    if (this.isDead) return Promise.resolve(false)\n\n    // do nothing if already running\n    if (this._isApplying) {\n      this._reApply = true\n      return Promise.resolve(false)\n    }\n    this._isApplying = true\n\n    let stopCriteria = false\n    const received = []\n\n    const handleMessage = (msg) => {\n      if (msg.context === 'leader' && msg.token !== this.token) {\n        received.push(msg)\n\n        if (msg.action === 'apply') {\n          // Other is applying\n          if (msg.token > this.token) {\n            // Other has higher token, stop applying\n            stopCriteria = true\n          }\n        }\n\n        if (msg.action === 'tell') {\n          // Other is already leader\n          stopCriteria = true\n        }\n      }\n    }\n    this._channel.addEventListener('internal', handleMessage)\n\n    return _sendMessage(this, 'apply') // send out that this one is applying\n      .then(() => sleep(this._options.responseTime)) // let others time to respond\n      .then(() => {\n        if (stopCriteria) return Promise.reject(new Error())\n        else return _sendMessage(this, 'apply')\n      })\n      .then(() => sleep(this._options.responseTime)) // let others time to respond\n      .then(() => {\n        if (stopCriteria) return Promise.reject(new Error())\n        else return _sendMessage(this)\n      })\n      .then(() => beLeader(this)) // no one disagreed -> this one is now leader\n      .then(() => true)\n      .catch(() => false) // apply not successful\n      .then(success => {\n        this._channel.removeEventListener('internal', handleMessage)\n        this._isApplying = false\n        if (!success && this._reApply) {\n          this._reApply = false\n          return this.applyOnce()\n        } else return success\n      })\n  }\n\n  awaitLeadership () {\n    if (\n      !this._awaitLeadershipPromise\n    ) {\n      this._awaitLeadershipPromise = _awaitLeadershipOnce(this)\n    }\n    return this._awaitLeadershipPromise\n  }\n\n  set onDuplicate (fn) {\n    this._duplicateListeners = fn\n  }\n\n  /* istanbul ignore next */\n  get onDuplicate () {\n    return this._duplicateListeners\n  }\n\n  set onBeforeDie (fn) {\n    this._onBeforeDie = fn\n  }\n\n  /* istanbul ignore next */\n  get onBeforeDie () {\n    return this._onBeforeDie\n  }\n\n  async die () {\n    if (this.isDead) return\n    this.isDead = true\n\n    await this.onBeforeDie()\n    this._listeners.forEach(listener => this._channel.removeEventListener('internal', listener))\n    this._intervals.forEach(interval => timer.clearInterval(interval))\n    this._unloadFns.forEach(uFn => {\n      if (IS_BROWSER) {\n        window.removeEventListener(uFn[0], uFn[1])\n      }\n    })\n    return _sendMessage(this, 'death')\n  }\n}\n\nfunction _awaitLeadershipOnce (leaderElector) {\n  if (leaderElector.isLeader) return Promise.resolve()\n\n  return new Promise(resolve => {\n    let resolved = false\n\n    function finish () {\n      /* istanbul ignore next */\n      if (resolved) {\n        return\n      }\n      resolved = true\n      timer.clearInterval(interval)\n      leaderElector._channel.removeEventListener('internal', whenDeathListener)\n      resolve(true)\n    }\n\n    // try once now\n    leaderElector.applyOnce().then(() => {\n      if (leaderElector.isLeader) {\n        finish()\n      }\n    })\n\n    // try on fallbackInterval\n    const interval = timer.setInterval(() => {\n      /* istanbul ignore next */\n      leaderElector.applyOnce().then(() => {\n        if (leaderElector.isLeader) {\n          finish()\n        }\n      })\n    }, leaderElector._options.fallbackInterval)\n    leaderElector._intervals.push(interval)\n\n    // try when other leader dies\n    const whenDeathListener = msg => {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector.applyOnce().then(() => {\n          if (leaderElector.isLeader) finish()\n        })\n      }\n    }\n    leaderElector._channel.addEventListener('internal', whenDeathListener)\n    leaderElector._listeners.push(whenDeathListener)\n  })\n}\n\n/**\n * Sends and internal message over the broadcast-channel\n */\nfunction _sendMessage (leaderElector, action) {\n  const msgJson = {\n    context: 'leader',\n    action,\n    token: leaderElector.token\n  }\n  return leaderElector._channel.postInternal(msgJson)\n}\n\nexport function beLeader (leaderElector) {\n  leaderElector.isLeader = true\n\n  const isLeaderListener = msg => {\n    if (msg.context === 'leader' && msg.action === 'apply') {\n      _sendMessage(leaderElector, 'tell')\n    }\n\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._duplicateCalled) {\n      /**\n       * Another instance is also leader!\n       * This can happen on rare events\n       * like when the CPU is at 100% for long time\n       * or the tabs are open very long and the browser throttles them.\n       */\n      leaderElector._duplicateCalled = true\n      leaderElector._duplicateListeners() // message the lib user so the app can handle the problem\n      _sendMessage(leaderElector, 'tell') // ensure other leader also knows the problem\n    }\n  }\n  leaderElector._channel.addEventListener('internal', isLeaderListener)\n  leaderElector._listeners.push(isLeaderListener)\n  return _sendMessage(leaderElector, 'tell')\n}\n\nexport function createLeaderElection (channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('❌ MessageChannel already has a leader-elector')\n  }\n\n  const elector = new LeaderElection(channel, options)\n  channel._beforeClose.push(async () => elector.die())\n\n  channel._leaderElector = elector\n  return elector\n}\n","import { MessageChannel, createLeaderElection } from './MessageChannel'\nexport const TabManager = ({\n  type,\n  channelName,\n  fallbackInterval,\n  responseTime,\n  emitOnAllTabs,\n  callbacks,\n  start,\n  reset,\n  pause,\n  resume\n}) => {\n  const channel = new MessageChannel(channelName, { type })\n  const elector = createLeaderElection(channel, { fallbackInterval, responseTime })\n  const registry = {}\n\n  // Register self\n  registry[elector.token] = false\n\n  let leader = false\n  let allIdle = true\n\n  const isLeader = () => leader\n\n  elector.awaitLeadership().then(() => {\n    leader = true\n  })\n\n  channel.addEventListener('message', ([type, id]) => {\n    switch (type) {\n      case 'register':\n        registry[id] = false\n        break\n      case 'deregister':\n        delete registry[id]\n        break\n      case 'idle':\n        idle(id)\n        break\n      case 'active':\n        active(id)\n        break\n      case 'emitIdle':\n        callbacks.onIdle()\n        break\n      case 'emitActive':\n        callbacks.onActive()\n        break\n      case 'start':\n        start(true)\n        break\n      case 'reset':\n        reset(true)\n        break\n      case 'pause':\n        pause(true)\n        break\n      case 'resume':\n        resume(true)\n        break\n      default:\n        // no op\n    }\n  })\n\n  const setAllIdle = bool => {\n    allIdle = bool\n  }\n\n  const isAllIdle = () => allIdle\n\n  const idle = (id = elector.token) => {\n    registry[id] = true\n    const isIdle = Object.values(registry).every(v => v)\n    if (!allIdle && isIdle) {\n      allIdle = true\n      if (isLeader()) {\n        callbacks.onIdle()\n        if (emitOnAllTabs) send('emitIdle')\n      } else {\n        send('idle')\n      }\n    }\n  }\n\n  const active = (id = elector.token) => {\n    registry[id] = false\n    const isActive = Object.values(registry).some(v => !v)\n    if (allIdle && isActive) {\n      allIdle = false\n      if (isLeader()) {\n        callbacks.onActive()\n        if (emitOnAllTabs) send('emitActive')\n      } else {\n        send('active')\n      }\n    }\n  }\n\n  /* istanbul ignore next */\n  elector.onDuplicate = async () => await elector.die()\n  elector.onBeforeDie = async () => await send('deregister')\n\n  const send = async message => channel.postMessage([message, elector.token])\n\n  const close = async () => {\n    await elector.die()\n    await channel.close()\n  }\n\n  // Register self with remote tabs\n  send('register')\n\n  return { close, send, isLeader, idle, active, isAllIdle, setAllIdle }\n}\n","/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name IdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport timer from './timer'\nimport { TabManager } from './TabManager'\nimport { IS_BROWSER, DEFAULT_ELEMENT, DEFAULT_EVENTS, debounced, throttled } from './utils'\n\n/**\n * Detects when your user is idle\n * @class IdleTimer\n * @private\n */\nclass IdleTimer extends Component {\n  /**\n   * Creates an instance of IdleTimer\n   * bind all of our internal events here\n   * for best performance\n   * @param {Object} props\n   * @return {IdleTimer}\n   * @private\n   */\n  constructor (props) {\n    super(props)\n\n    /**\n     * Sets initial component state\n     * @type {Object}\n     * @private\n     */\n    this.state = {\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      lastIdle: null,\n      idleTime: 0,\n      remaining: null,\n      pageX: null,\n      pageY: null\n    }\n\n    /**\n     * The timer instance\n     * @type {Timeout}\n     * @private\n     */\n    this.tId = null\n\n    /**\n     * Wether or not events are bound\n     * @type {boolean}\n     * @private\n     */\n    this.eventsBound = false\n\n    this.callbackRefs = {}\n\n    // Debounce and throttle can't both be set\n    if (props.debounce > 0 && props.throttle > 0) {\n      throw new Error('onAction can either be throttled or debounced (not both)')\n    }\n\n    // Create debounced action if applicable\n    if (props.debounce > 0) {\n      this._onAction = debounced(props.onAction, props.debounce)\n\n    // Create throttled action if applicable\n    } else if (props.throttle > 0) {\n      this._onAction = throttled(props.onAction, props.throttle)\n\n    // Set custom onAction\n    } else {\n      this._onAction = props.onAction\n    }\n\n    // Create a throttle event handler if applicable\n    if (props.eventsThrottle > 0) {\n      this.handleEvent = throttled(this._handleEvent.bind(this), props.eventsThrottle)\n    } else {\n      this.handleEvent = this._handleEvent.bind(this)\n    }\n\n    // If startOnMount is set, idle state defaults to true\n    if (!props.startOnMount || props.startManually) {\n      this.state.idle = true\n    }\n\n    // Bind all events to component scope, built for speed 🚀\n    this._toggleIdleState = this._toggleIdleState.bind(this)\n    this.start = this.start.bind(this)\n    this.reset = this.reset.bind(this)\n    this.pause = this.pause.bind(this)\n    this.resume = this.resume.bind(this)\n    this.isIdle = this.isIdle.bind(this)\n    this.getRemainingTime = this.getRemainingTime.bind(this)\n    this.getElapsedTime = this.getElapsedTime.bind(this)\n    this.getLastActiveTime = this.getLastActiveTime.bind(this)\n    this.getLastIdleTime = this.getLastIdleTime.bind(this)\n    this.getTotalIdleTime = this.getTotalIdleTime.bind(this)\n    this.getTotalActiveTime = this.getTotalActiveTime.bind(this)\n  }\n\n  /**\n   * Runs once the component has mounted\n   * here we handle automatically starting\n   * the idletimer\n   * @private\n   */\n  componentDidMount () {\n    const { startOnMount, startManually } = this.props\n\n    // Set up cross tab\n    this._setupTabManager()\n\n    if (startManually) return\n    if (startOnMount) {\n      this.start()\n    } else {\n      this._bindEvents()\n    }\n  }\n\n  componentDidUpdate (prevProps) {\n    // Update debounce function\n    if ((prevProps.debounce !== this.props.debounce) && this.props.debounce > 0) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = debounced(this.props.onAction, this.props.debounce)\n    } else\n    // Update throttle function\n    if ((prevProps.throttle !== this.props.throttle) && this.props.throttle > 0) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = throttled(this.props.onAction, this.props.throttle)\n    } else\n    // Remove throttle or debounce\n    if (\n      (prevProps.throttle && this.props.throttle === 0) ||\n      (prevProps.debounce && this.props.debounce === 0)\n    ) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = this.props.onAction\n    }\n\n    // Update event throttle function\n    if (prevProps.eventsThrottle !== this.props.eventsThrottle) {\n      this._unbindEvents()\n      this.handleEvent = throttled(this._handleEvent.bind(this), this.props.eventsThrottle)\n      this._bindEvents()\n    }\n    // Update timeout value\n    if (prevProps.timeout !== this.props.timeout) {\n      if (this.state.idle) this.reset()\n    }\n\n    // Update callback refs\n    if (prevProps.onActive !== this.props.onActive) this.callbackRefs.onActive = this.props.onActive\n    if (prevProps.onIdle !== this.props.onIdle) this.callbackRefs.onIdle = this.props.onIdle\n  }\n\n  /**\n   * Called before the component un-mounts\n   * here we clear the timer and remove\n   * all the event listeners\n   * @private\n   */\n  componentWillUnmount () {\n    // Clear timeout to prevent delayed state changes\n    timer.clearTimeout(this.tId)\n    this._unbindEvents(true)\n    // Cancel any debounced onAction handlers\n    if (this._onAction.cancel) this._onAction.cancel()\n    /* istanbul ignore next */\n    if (this.manager) {\n      this.manager.close().catch(console.error)\n    }\n  }\n\n  /**\n   * Render children if IdleTimer is used as a wrapper\n   * @return {Component} children\n   * @private\n   */\n  render () {\n    const { children } = this.props\n    return children || null\n  }\n\n  /**\n   * Setup the Tab Manager.\n   * @private\n   */\n  _setupTabManager () {\n    const { crossTab, onIdle, onActive } = this.props\n    this.callbackRefs = { onIdle, onActive }\n\n    /* istanbul ignore next */\n    if (crossTab) {\n      const {\n        type,\n        channelName,\n        fallbackInterval,\n        responseTime,\n        emitOnAllTabs\n      } = Object.assign({\n        channelName: 'idle-timer',\n        fallbackInterval: 2000,\n        responseTime: 100,\n        removeTimeout: 1000 * 60,\n        emitOnAllTabs: false\n      }, crossTab === true ? {} : crossTab)\n\n      this.manager = TabManager({\n        type,\n        channelName,\n        fallbackInterval,\n        responseTime,\n        emitOnAllTabs,\n        callbacks: this.callbackRefs,\n        start: this.start,\n        reset: this.reset,\n        pause: this.pause,\n        resume: this.resume\n      })\n    }\n  }\n\n  /**\n   * Binds the specified events\n   * @private\n   */\n  _bindEvents () {\n    // Don't bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    const { element, events, passive, capture } = this.props\n    if (!this.eventsBound) {\n      events.forEach(e => {\n        element.addEventListener(e, this.handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.eventsBound = true\n    }\n  }\n\n  /**\n   * Unbinds all the bound events\n   * @private\n   */\n  _unbindEvents (force = false) {\n    // If we are not in a browser\n    // we don't need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    const { element, events, passive, capture } = this.props\n    if (this.eventsBound || force) {\n      events.forEach(e => {\n        element.removeEventListener(e, this.handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.eventsBound = false\n    }\n  }\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  _toggleIdleState (e) {\n    // Fire the appropriate action\n    // and pass the event through\n    // Toggle the idle state\n    this.setState((prevState) => ({\n      idle: !prevState.idle,\n      lastIdle: !prevState.idle ? (+new Date()) - this.props.timeout : prevState.lastIdle,\n      idleTime: prevState.idle ? prevState.idleTime + (+new Date()) - prevState.lastIdle : prevState.idleTime\n    }), () => {\n      const { onActive, onIdle, stopOnIdle } = this.props\n      const { idle } = this.state\n      if (idle) {\n        if (stopOnIdle) {\n          // Clear any existing timeout\n          timer.clearTimeout(this.tId)\n          this.tId = null\n          // Unbind events\n          this._unbindEvents()\n        }\n\n        if (this.manager) {\n          /* istanbul ignore next */\n          this.manager.idle()\n        } else {\n          onIdle(e)\n        }\n      } else {\n        this._bindEvents()\n        if (this.manager) {\n          /* istanbul ignore next */\n          this.manager.active()\n        } else {\n          onActive(e)\n        }\n      }\n    })\n  }\n\n  /**\n   * Event handler for supported event types\n   * @param  {Object} e event object\n   * @private\n   */\n  _handleEvent (e) {\n    const { remaining, pageX, pageY, idle } = this.state\n    const { timeout, stopOnIdle } = this.props\n\n    // Fire onAction event\n    this._onAction(e)\n\n    // Already active, ignore events\n    if (remaining) return\n\n    // Mousemove event\n    if (e.type === 'mousemove') {\n      // If coords are same, it didn't move\n      /* istanbul ignore next */\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coords don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      /* istanbul ignore next */\n      const elapsed = this.getElapsedTime()\n      /* istanbul ignore next */\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Clear any existing timeout\n    timer.clearTimeout(this.tId)\n    this.tId = null\n\n    // Determine last time User was active, as can't rely on timer.setTimeout ticking at the correct interval\n    const elapsedTimeSinceLastActive = +new Date() - this.getLastActiveTime()\n\n    // If the user is idle or last active time is more than timeout, flip the idle state\n    if ((idle && !stopOnIdle) || (!idle && elapsedTimeSinceLastActive > timeout)) {\n      this._toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    this.setState({\n      lastActive: +new Date(),\n      pageX: e.pageX,\n      pageY: e.pageY\n    })\n\n    // If the user is idle and stopOnIdle flag is not set\n    // set a new timeout\n    if (idle) {\n      if (!stopOnIdle) {\n        this.tId = timer.setTimeout(this._toggleIdleState, timeout)\n      }\n    } else {\n      this.tId = timer.setTimeout(this._toggleIdleState, timeout)\n    }\n  }\n\n  /**\n   * Set initial state and start timer\n   * @name start\n   */\n  start (remote = true) {\n    // Clear timeout\n    timer.clearTimeout(this.tId)\n    this.tId = null\n\n    // Bind the events\n    this._bindEvents()\n\n    // Reset state\n    this.setState({\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null\n    })\n\n    if (this.manager) {\n      /* istanbul ignore next */\n      this.manager.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('start')\n      }\n    }\n\n    // Set new timeout\n    const { timeout } = this.props\n    this.tId = timer.setTimeout(this._toggleIdleState, timeout)\n  }\n\n  /**\n   * Restore initial state and restart timer, calling onActive\n   * @name reset\n   */\n  reset (remote = false) {\n    // Clear timeout\n    timer.clearTimeout(this.tId)\n    this.tId = null\n\n    // Bind the events\n    this._bindEvents()\n\n    if (this.state.idle) {\n      if (this.manager) {\n        /* istanbul ignore next */\n        this.manager.active()\n      } else {\n        this.props.onActive()\n      }\n    }\n\n    if (this.manager) {\n      /* istanbul ignore next */\n      this.manager.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('reset')\n      }\n    }\n\n    // Reset state\n    this.setState({\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null\n    })\n\n    // Set new timeout\n    const { timeout } = this.props\n    this.tId = timer.setTimeout(this._toggleIdleState, timeout)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  pause (remote = false) {\n    // Timer is already paused\n    const { remaining } = this.state\n    if (remaining !== null) return\n\n    // Unbind events\n    this._unbindEvents()\n\n    // Clear existing timeout\n    timer.clearTimeout(this.tId)\n    this.tId = null\n\n    // Send event to other tabs\n    if (this.manager) {\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('pause')\n      }\n    }\n\n    // Define how much is left on the timer\n    this.setState({\n      remaining: this.getRemainingTime()\n    })\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  resume (remote = false) {\n    // Timer is not paused\n    const { remaining, idle } = this.state\n    if (remaining === null) return\n\n    // Bind events\n    this._bindEvents()\n\n    // Send event to other tabs\n    if (this.manager) {\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('resume')\n      }\n    }\n\n    // Start timer and clear remaining\n    // if we are in the active state\n    if (!idle) {\n      // Set a new timeout\n      this.tId = timer.setTimeout(this._toggleIdleState, remaining)\n      // Set new state\n      this.setState({ remaining: null, lastActive: +new Date() })\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {number} Milliseconds remaining\n   */\n  getRemainingTime () {\n    const { remaining, lastActive } = this.state\n    const { timeout } = this.props\n\n    // If idle there is no time remaining\n    if (remaining !== null) {\n      return remaining < 0 ? 0 : remaining\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    const timeLeft = timeout - ((+new Date()) - lastActive)\n    return timeLeft < 0 ? 0 : timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  getElapsedTime () {\n    const { oldDate } = this.state\n    return (+new Date()) - oldDate\n  }\n\n  /**\n   * Last time the user was idle\n   * @name getLastIdleTime\n   * @return {Timestamp}\n   */\n  getLastIdleTime () {\n    const { lastIdle } = this.state\n    return lastIdle\n  }\n\n  /**\n   * Total time the user was idle\n   * @name getTotalIdleTime\n   * @return {number}\n   */\n  getTotalIdleTime () {\n    const { idle, lastIdle, idleTime } = this.state\n    if (idle) {\n      return ((+new Date()) - lastIdle) + idleTime\n    } else {\n      return idleTime\n    }\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  getLastActiveTime () {\n    const { lastActive } = this.state\n    return lastActive\n  }\n\n  /**\n   * Total time the user was active\n   * @name getTotalActiveTime\n   * @return {number}\n   */\n  getTotalActiveTime () {\n    return this.getElapsedTime() - this.getTotalIdleTime()\n  }\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {boolean}\n   */\n  isIdle () {\n    const { idle } = this.state\n    return idle\n  }\n\n  /**\n   * Returns wether or not this is the leader tab\n   * @name isLeader\n   * @return {boolean}\n   */\n  isLeader () {\n    return this.manager ? this.manager.isLeader() : true\n  }\n}\n\n/**\n * Type checks for every property\n * @type {Object}\n * @private\n */\nIdleTimer.propTypes = {\n  /**\n   * Activity Timeout in milliseconds\n   * default: 1200000\n   * @type {Number}\n   */\n  timeout: PropTypes.number,\n  /**\n   * DOM events to listen to\n   * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n   * @type {Array}\n   */\n  events: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * Function to call when user is idle\n   * default: () => {}\n   * @type {Function}\n   */\n  onIdle: PropTypes.func,\n  /**\n   * Function to call when user becomes active\n   * default: () => {}\n   * @type {Function}\n   */\n  onActive: PropTypes.func,\n  /**\n   * Function to call on user actions\n   * default: () => {}\n   * @type {Function}\n   */\n  onAction: PropTypes.func,\n  /**\n   * Debounce the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {Number}\n   */\n  debounce: PropTypes.number,\n  /**\n   * Throttle the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {Number}\n   */\n  throttle: PropTypes.number,\n  /**\n   * Throttle the event handler function by setting delay in milliseconds\n   * default: 200\n   * @type {Number}\n   */\n  eventsThrottle: PropTypes.number,\n  /**\n   * Element reference to bind activity listeners to\n   * default: document\n   * @type {Object}\n   */\n  element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n  /**\n   * Start the timer on mount\n   * default: true\n   * @type {Boolean}\n   */\n  startOnMount: PropTypes.bool,\n  /**\n   * Require the timer to be started manually.\n   * default: false\n   * @type {Boolean}\n   */\n  startManually: PropTypes.bool,\n  /**\n   * Once the user goes idle the IdleTimer will not\n   * reset on user input instead, reset() must be\n   * called manually to restart the timer\n   * default: false\n   * @type {Boolean}\n   */\n  stopOnIdle: PropTypes.bool,\n  /**\n   * Bind events passively\n   * default: true\n   * @type {Boolean}\n   */\n  passive: PropTypes.bool,\n  /**\n   * Capture events\n   * default: true\n   * @type {Boolean}\n   */\n  capture: PropTypes.bool,\n  /**\n   * Cross Tab functionality.\n   * default: false\n   * @type {Boolean|Object}\n   */\n  crossTab: PropTypes.oneOfType([\n    PropTypes.bool,\n    PropTypes.shape({\n      type: PropTypes.oneOf(['broadcastChannel', 'localStorage', 'simulate']),\n      channelName: PropTypes.string,\n      fallbackInterval: PropTypes.number,\n      responseTime: PropTypes.number,\n      removeTimeout: PropTypes.number,\n      emitOnAllTabs: PropTypes.bool\n    })\n  ])\n}\n\n/**\n * Sets default property values\n * @type {Object}\n * @private\n */\nIdleTimer.defaultProps = {\n  timeout: 1000 * 60 * 20,\n  element: DEFAULT_ELEMENT,\n  events: DEFAULT_EVENTS,\n  onIdle: () => { },\n  onActive: () => { },\n  onAction: () => { },\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: true,\n  startManually: false,\n  stopOnIdle: false,\n  capture: true,\n  passive: true,\n  crossTab: false\n}\n\nexport default IdleTimer\n","/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name useIdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { useEffect, useRef, useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport timer from './timer'\nimport { TabManager } from './TabManager'\nimport { IS_BROWSER, DEFAULT_ELEMENT, DEFAULT_EVENTS, debounced, throttled } from './utils'\n\n/**\n * Detects when your user is idle\n * @function useIdleTimer\n * @private\n */\nfunction useIdleTimer ({\n  timeout = 1000 * 60 * 20,\n  element = DEFAULT_ELEMENT,\n  events = DEFAULT_EVENTS,\n  onIdle = () => { },\n  onActive = () => { },\n  onAction = () => { },\n  debounce = 0,\n  throttle = 0,\n  eventsThrottle = 200,\n  startOnMount = true,\n  startManually = false,\n  stopOnIdle = false,\n  capture = true,\n  passive = true,\n  crossTab = false\n} = {}) {\n  const eventsBound = useRef(false)\n  const idle = useRef(true)\n  const oldDate = useRef(+new Date())\n  const remaining = useRef(null)\n  const pageX = useRef(null)\n  const pageY = useRef(null)\n  const tId = useRef(null)\n  const lastActive = useRef(null)\n  const lastIdle = useRef(null)\n  const idleTime = useRef(0)\n  const firstLoad = useRef(true)\n  const _timeout = useRef(timeout)\n  const manager = useRef(null)\n\n  /* istanbul ignore next */\n  if (crossTab) {\n    if (crossTab === true) crossTab = {}\n    crossTab = Object.assign({\n      channelName: 'idle-timer',\n      fallbackInterval: 2000,\n      responseTime: 100,\n      removeTimeout: 1000 * 60,\n      emitOnAllTabs: false\n    }, crossTab)\n  }\n\n  // Event emitters\n  const emitOnIdle = useRef(onIdle)\n  const emitOnActive = useRef(onActive)\n  const emitOnAction = useRef(onAction)\n\n  useEffect(() => {\n    emitOnIdle.current = onIdle\n  }, [onIdle])\n\n  useEffect(() => {\n    emitOnActive.current = onActive\n  }, [onActive])\n\n  useEffect(() => {\n    emitOnAction.current = onAction\n  }, [onAction])\n\n  const intermediateOnAction = useMemo(() => {\n    function callOnAction (e) {\n      emitOnAction.current(e)\n    }\n\n    // Cancel any existing debounce timeouts\n    if (callOnAction.cancel) callOnAction.cancel()\n\n    // Create debounced action if applicable\n    if (debounce > 0) {\n      return debounced(callOnAction, debounce)\n\n      // Create throttled action if applicable\n    } else if (throttle > 0) {\n      return throttled(callOnAction, throttle)\n\n      // No throttle or debounce\n    } else {\n      return callOnAction\n    }\n  }, [throttle, debounce])\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  const _toggleIdleState = e => {\n    const nextIdle = !idle.current\n    idle.current = nextIdle\n    if (nextIdle) {\n      if (stopOnIdle) {\n        // Clear any existing timeout\n        timer.clearTimeout(tId.current)\n        tId.current = null\n        // Unbind events\n        _unbindEvents()\n      }\n      lastIdle.current = (+new Date()) - _timeout.current\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.idle()\n      } else {\n        emitOnIdle.current(e)\n      }\n    } else {\n      idleTime.current += (+new Date()) - lastIdle.current\n      _bindEvents()\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.active()\n      } else {\n        emitOnActive.current(e)\n      }\n    }\n  }\n\n  /**\n   * Event handler\n   * @param {Event} e\n   */\n  const _handleEvent = e => {\n    // Fire onAction event\n    intermediateOnAction(e)\n\n    // Already active, ignore events\n    if (remaining.current) return\n\n    // Mousemove event\n    /* istanbul ignore next */\n    if (e.type === 'mousemove') {\n      // If coords are same, it didn't move\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coords don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      const elapsed = getElapsedTime()\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Clear any existing timeout\n    timer.clearTimeout(tId.current)\n    tId.current = null\n\n    // Determine last time User was active, as can't rely on timer.setTimeout ticking at the correct interval\n    const elapsedTimeSinceLastActive = +new Date() - getLastActiveTime()\n\n    // If the user is idle or last active time is more than timeout, flip the idle state\n    if (\n      (idle.current && !stopOnIdle) ||\n      (!idle.current && elapsedTimeSinceLastActive > _timeout.current)\n    ) {\n      _toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    lastActive.current = +new Date()\n    pageX.current = e.pageX\n    pageY.current = e.pageY\n\n    // If the user is active, set a new timeout\n    if (!idle.current) {\n      tId.current = timer.setTimeout(_toggleIdleState, _timeout.current)\n    }\n  }\n\n  /**\n   * Reference to current handleEvent function.\n   * @private\n   */\n  const handleEvent = useRef(_handleEvent)\n\n  /**\n   * Binds the specified events\n   * @private\n   */\n  const _bindEvents = () => {\n    // Don't bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    if (!eventsBound.current) {\n      events.forEach(e => {\n        element.addEventListener(e, handleEvent.current, {\n          capture,\n          passive\n        })\n      })\n      eventsBound.current = true\n    }\n  }\n\n  /**\n   * Unbinds all the bound events\n   * @private\n   */\n  const _unbindEvents = (force = false) => {\n    // If we are not in a browser\n    // we don't need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    if (eventsBound.current || force) {\n      events.forEach(e => {\n        element.removeEventListener(e, handleEvent.current, {\n          capture,\n          passive\n        })\n      })\n      eventsBound.current = false\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {number} Milliseconds remaining\n   */\n  const getRemainingTime = () => {\n    // If idle there is no time remaining\n    if (remaining.current !== null) {\n      return remaining.current < 0 ? 0 : remaining.current\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    const timeLeft = _timeout.current - ((+new Date()) - lastActive.current)\n    return timeLeft < 0 ? 0 : timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  const getElapsedTime = () => (+new Date()) - oldDate.current\n\n  /**\n   * Last time the user was idle\n   * @name getLastIdleTime\n   * @return {Timestamp}\n   */\n  const getLastIdleTime = () => lastIdle.current\n\n  /**\n   * Get the total time user is idle\n   * @name getTotalIdleTime\n   * @return {number} Milliseconds idle\n   */\n  const getTotalIdleTime = () => {\n    if (idle.current) {\n      return ((+new Date()) - lastIdle.current) + idleTime.current\n    } else {\n      return idleTime.current\n    }\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  const getLastActiveTime = () => lastActive.current\n\n  /**\n   * Get the total time user is active\n   * @name getTotalActiveTime\n   * @return {number} Milliseconds active\n   */\n  const getTotalActiveTime = () => getElapsedTime() - getTotalIdleTime()\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {Boolean}\n   */\n  const isIdle = () => idle.current\n\n  /**\n   * Returns wether or not this is the leader tab\n   * @returns {Boolean}\n   */\n  const isLeader = () => manager.current ? manager.current.isLeader() : true\n\n  /**\n  * Set initial state and start timer\n  * @name reset\n  */\n  const start = (remote = false) => {\n    // Clear timeout\n    timer.clearTimeout(tId.current)\n    tId.current = null\n\n    // Bind the events\n    _bindEvents()\n\n    // Set state\n    idle.current = false\n    oldDate.current = +new Date()\n    lastActive.current = +new Date()\n    remaining.current = null\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      manager.current.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('start')\n      }\n    }\n\n    // Set new timeout\n    tId.current = timer.setTimeout(_toggleIdleState, _timeout.current)\n  }\n\n  /**\n  * Restore initial state and restart timer, calling onActive\n  * @name reset\n  */\n  const reset = (remote = false) => {\n    // Clear timeout\n    timer.clearTimeout(tId.current)\n    tId.current = null\n\n    // Bind the events\n    _bindEvents()\n\n    // Emit active\n    if (idle.current) {\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.active()\n      } else {\n        emitOnActive.current()\n      }\n    }\n\n    // Reset state\n    idle.current = false\n    oldDate.current = +new Date()\n    lastActive.current = +new Date()\n    remaining.current = null\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      manager.current.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('reset')\n      }\n    }\n\n    // Set new timeout\n    tId.current = timer.setTimeout(_toggleIdleState, _timeout.current)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  const pause = (remote = false) => {\n    // Timer is already paused\n    if (remaining.current !== null) return\n\n    // Unbind events\n    _unbindEvents()\n\n    // Clear existing timeout\n    timer.clearTimeout(tId.current)\n    tId.current = null\n\n    // Define how much is left on the timer\n    remaining.current = getRemainingTime()\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('pause')\n      }\n    }\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  const resume = (remote = false) => {\n    // Timer is not paused\n    if (remaining.current === null) return\n\n    // Bind events\n    _bindEvents()\n\n    // Start timer and clear remaining\n    // if we are in the idle state\n    if (!idle.current) {\n      // Set a new timeout\n      tId.current = timer.setTimeout(_toggleIdleState, remaining.current)\n      // Set states\n      remaining.current = null\n      lastActive.current = +new Date()\n    }\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('resume')\n      }\n    }\n  }\n\n  /**\n   * Hook lifecycle\n   */\n  useEffect(() => {\n    // Debounce and throttle can't both be set\n    if (debounce > 0 && throttle > 0) {\n      throw new Error('onAction can either be throttled or debounced (not both)')\n    }\n\n    // Set up cross tab\n    /* istanbul ignore next */\n    if (crossTab) {\n      manager.current = TabManager({\n        type: crossTab.type,\n        channelName: crossTab.channelName,\n        fallbackInterval: crossTab.fallbackInterval,\n        responseTime: crossTab.responseTime,\n        emitOnAllTabs: crossTab.emitOnAllTabs,\n        callbacks: {\n          onIdle: emitOnIdle.current,\n          onActive: emitOnActive.current\n        },\n        start,\n        reset,\n        pause,\n        resume\n      })\n    }\n\n    // If startOnMount is enabled, start the timer\n    if (startManually) {\n      return async () => {\n        timer.clearTimeout(tId.current)\n        _unbindEvents(true)\n        if (crossTab) await manager.current.close()\n      }\n    }\n\n    if (startOnMount) {\n      start()\n    } else {\n      _bindEvents()\n    }\n\n    // Clear and unbind on unmount\n    return async () => {\n      timer.clearTimeout(tId.current)\n      _unbindEvents(true)\n      if (intermediateOnAction.cancel) intermediateOnAction.cancel()\n      if (crossTab) await manager.current.close()\n    }\n  }, [])\n\n  useEffect(() => {\n    const eventsWereBound = eventsBound.current\n    if (eventsWereBound) _unbindEvents()\n    if (eventsThrottle > 0) {\n      handleEvent.current = throttled(_handleEvent, eventsThrottle)\n    } else {\n      handleEvent.current = _handleEvent\n    }\n    if (eventsWereBound) _bindEvents()\n  }, [eventsThrottle])\n\n  useEffect(() => {\n    _timeout.current = timeout\n    if (!firstLoad.current && idle.current) {\n      reset()\n    }\n    firstLoad.current = false\n  }, [timeout])\n\n  return {\n    isIdle,\n    isLeader,\n    start,\n    pause,\n    reset,\n    resume,\n    getLastIdleTime,\n    getTotalIdleTime,\n    getLastActiveTime,\n    getTotalActiveTime,\n    getElapsedTime,\n    getRemainingTime\n  }\n}\n\n/**\n * Type checks for every property\n * @type {Object}\n * @private\n */\nuseIdleTimer.propTypes = {\n  /**\n   * Activity Timeout in milliseconds\n   * default: 1200000\n   * @type {number}\n   */\n  timeout: PropTypes.number,\n  /**\n   * DOM events to listen to\n   * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n   * @type {Array}\n   */\n  events: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * Function to call when user is idle.\n   * default: () => {}\n   * @type {Function}\n   */\n  onIdle: PropTypes.func,\n  /**\n   * Function to call when user becomes active.\n   * default: () => {}\n   * @type {Function}\n   */\n  onActive: PropTypes.func,\n  /**\n   * Function to call on user actions.\n   * default: () => {}\n   * @type {Function}\n   */\n  onAction: PropTypes.func,\n  /**\n   * Debounce the onAction function by setting delay in milliseconds.\n   * default: 0\n   * @type {number}\n   */\n  debounce: PropTypes.number,\n  /**\n   * Throttle the onAction function by setting delay in milliseconds.\n   * default: 0\n   * @type {number}\n   */\n  throttle: PropTypes.number,\n  /**\n   * Throttle the event handler function by setting delay in milliseconds.\n   * default: 200\n   * @type {number}\n   */\n  eventsThrottle: PropTypes.number,\n  /**\n   * Element reference to bind activity listeners to.\n   * default: document\n   * @type {Object}\n   */\n  element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n  /**\n   * Start the timer on mount.\n   * default: true\n   * @type {Boolean}\n   */\n  startOnMount: PropTypes.bool,\n  /**\n   * Require the timer to be started manually.\n   * default: false\n   * @type {Boolean}\n   */\n  startManually: PropTypes.bool,\n  /**\n   * Once the user goes idle the IdleTimer will not\n   * reset on user input instead, start() or reset() must be\n   * called manually to restart the timer.\n   * default: false\n   * @type {Boolean}\n   */\n  stopOnIdle: PropTypes.bool,\n  /**\n   * Bind events passively.\n   * default: true\n   * @type {Boolean}\n   */\n  passive: PropTypes.bool,\n  /**\n   * Capture events.\n   * default: true\n   * @type {Boolean}\n   */\n  capture: PropTypes.bool,\n  /**\n   * Cross Tab functionality.\n   * default: false\n   * @type {Boolean|Object}\n   */\n  crossTab: PropTypes.oneOfType([\n    PropTypes.bool,\n    PropTypes.shape({\n      type: PropTypes.oneOf(['broadcastChannel', 'localStorage', 'simulate']),\n      channelName: PropTypes.string,\n      fallbackInterval: PropTypes.number,\n      responseTime: PropTypes.number,\n      removeTimeout: PropTypes.number,\n      emitOnAllTabs: PropTypes.bool\n    })\n  ])\n}\n\n/**\n * Sets default property values\n * @type {Object}\n * @private\n */\nuseIdleTimer.defaultProps = {\n  timeout: 1000 * 60 * 20,\n  element: DEFAULT_ELEMENT,\n  events: DEFAULT_EVENTS,\n  onIdle: () => { },\n  onActive: () => { },\n  onAction: () => { },\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: true,\n  startManually: false,\n  stopOnIdle: false,\n  capture: true,\n  passive: true,\n  crossTab: false\n}\n\nexport default useIdleTimer\n"],"names":["MAX_SAFE_INTEGER","undefined","Number","LAST_NUMBER_WEAK_MAP","WeakMap","lastNumberWeakMap","generateUniqueNumber","cache","collection","lastNumber","get","nextNumber","size","TWO_TO_THE_POWER_OF_TWENTY_NINE","has","Math","floor","random","Error","createGenerateUniqueNumber","set","workerTimers","loadWorkerTimers","load","worker","blob","Blob","type","url","URL","createObjectURL","setTimeout","revokeObjectURL","createLoadWorkerTimers","scheduledIntervalFunctions","Map","scheduledTimeoutFunctions","unrespondedRequests","Worker","addEventListener","data","message","method","params","timerId","timerType","idOrFunc","timerIdAndTimerType","delete","error","id","isClearResponse","clearInterval","postMessage","clearTimeout","setInterval","func","delay","now","performance","isWebWorkerSupported","window","timer","intervalId","timeoutId","callback","workerTimers.setInterval","workerTimers.setTimeout","IS_BROWSER","DEFAULT_ELEMENT","document","DEFAULT_EVENTS","debounced","fn","result","args","cancel","throttled","lastCall","Date","getTime","lastMs","additional","microSeconds","ms","randomToken","toString","substring","sleep","time","Promise","resolve","channelName","state","messagesCallback","bc","BroadcastChannel","onmessage","msg","channelState","close","messageJson","err","reject","ObliviousSet","[object Object]","ttl","this","Set","timeMap","value","add","_removeTooOldValues","clear","olderThen","iterator","Symbol","next","getLocalStorage","localStorage","e","canBeUsed","ls","key","setItem","removeItem","options","uuid","eMIs","removeTimeout","listener","ev","JSON","parse","newValue","addStorageEventListener","msgObj","token","messagesCallbackTime","removeEventListener","writeObj","stringify","createEvent","initEvent","dispatchEvent","userAgent","navigator","toLowerCase","includes","defaultTime","SIMULATE_CHANNELS","create","name","onMessage","Array","from","filter","channel","forEach","averageResponseTime","METHODS","BroadcastChannelMethod","LocalStorageMethod","MessageChannel","SimulateMethod","find","m","useMethod","map","chooseMethod","closed","_isListening","_onMessageListener","_addEventListeners","internal","_unSendMessagePromises","_beforeClose","_preparePromises","maybePromise","obj","then","s","_state","_prepareChannel","_post","listenObj","_removeListenerObject","_addListenerObject","awaitPrepare","all","messageChannel","sendPromise","catch","_hasMessageListeners","length","push","listenerFn","_startListening","o","_stopListening","LeaderElection","_channel","_options","isLeader","isDead","_isApplying","_reApply","_unloadFns","_listeners","_intervals","_duplicateListeners","_duplicateCalled","_onBeforeDie","async","unloadFn","die","stopCriteria","handleMessage","context","action","_sendMessage","responseTime","leaderElector","isLeaderListener","beLeader","success","applyOnce","_awaitLeadershipPromise","resolved","finish","interval","whenDeathListener","fallbackInterval","onDuplicate","onBeforeDie","uFn","msgJson","postInternal","TabManager","emitOnAllTabs","callbacks","start","reset","pause","resume","elector","_leaderElector","createLeaderElection","registry","leader","allIdle","awaitLeadership","idle","active","onIdle","onActive","isIdle","Object","values","every","v","send","isActive","some","isAllIdle","setAllIdle","bool","IdleTimer","Component","props","super","oldDate","lastActive","lastIdle","idleTime","remaining","pageX","pageY","tId","eventsBound","callbackRefs","debounce","throttle","_onAction","onAction","eventsThrottle","handleEvent","_handleEvent","bind","startOnMount","startManually","_toggleIdleState","getRemainingTime","getElapsedTime","getLastActiveTime","getLastIdleTime","getTotalIdleTime","getTotalActiveTime","_setupTabManager","_bindEvents","prevProps","_unbindEvents","timeout","manager","console","children","crossTab","assign","element","events","passive","capture","force","setState","prevState","stopOnIdle","elapsedTimeSinceLastActive","remote","timeLeft","useIdleTimer","useRef","firstLoad","_timeout","emitOnIdle","emitOnActive","emitOnAction","useEffect","current","intermediateOnAction","useMemo","callOnAction","nextIdle","eventsWereBound","propTypes","PropTypes","number","arrayOf","string","oneOfType","object","shape","oneOf","defaultProps"],"mappings":"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"}